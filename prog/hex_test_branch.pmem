0000      // nop
7411      // lil r1, 7
8421      // lil r2, 8
8431      // lil r3, 8
9441      // lil r4, 9
1451      // lil r5, 1
0000      // nop
0000      // nop
//=====================================================
// Test #1: BEQ should not take branch  => dmem[ 2] = 0
//=====================================================
0553      // sho r5(value), r0(offset), 0x2(base) : set mem 0x2 to one
0002
1203      // beq r1, r2, 8
0008            
0053      // sho r0(value), r0(offset), 0x2(base) : set mem 0x2 back to zero if branch not taken
0002
0000      // nop
0000      // nop
//=====================================================
// Test #2: BEQ should take branch      => dmem[ 4] = 1
//=====================================================
0553      // sho r5(value), r0(offset), 0x4(base) : set mem 0x4 to one
0004
2303      // beq r2, r3, 8
0008            
0053      // sho r0(value), r0(offset), 0x4(base) : set mem 0x4 back to zero if branch not taken
0004
0000      // nop
0000      // nop
//=====================================================
// Test #3: BNEQ should not take branch => dmem[ 6] = 0
//=====================================================
0553      // sho r5(value), r0(offset), 0x6(base) : set mem 0x6 to one
0006
2313      // bneq r2, r3, 8
0008            
0053      // sho r0(value), r0(offset), 0x6(base) : set mem 0x6 back to zero if branch not taken
0006
0000      // nop
0000      // nop
//=====================================================
// Test #4: BNEQ should take branch     => dmem[ 8] = 1
//=====================================================
0553      // sho r5(value), r0(offset), 0x8(base) : set mem 0x8 to one
0008
1213      // bneq r1, r2, 8
0008            
0053      // sho r0(value), r0(offset), 0x8(base) : set mem 0x8 back to zero if branch not taken
0008
0000      // nop
0000      // nop
//=====================================================
// Test #5: BGE should not take branch  => dmem[10] = 0
//=====================================================
0553      // sho r5(value), r0(offset), 0xA(base) : set mem 0xA to one
000A
2123      // bge r1, r2, 8 (r1 >= r2)
0008            
0053      // sho r0(value), r0(offset), 0xA(base) : set mem 0xA back to zero if branch not taken
000A
0000      // nop
0000      // nop
//=====================================================
// Test #6: BGE should take branch      => dmem[12] = 1
//=====================================================
0553      // sho r5(value), r0(offset), 0xC(base) : set mem 0xC to one
000C
1323      // bge r3, r1, 8 (r3 >= r1) 
0008            
0053      // sho r0(value), r0(offset), 0xC(base) : set mem 0xC back to zero if branch not taken
000C
0000      // nop
0000      // nop
//=====================================================
// Test #7: BLT should not take branch  => dmem[14] = 0
//=====================================================
0553      // sho r5(value), r0(offset), 0xE(base) : set mem 0xE to one
000E
3433      // blt r4, r3, 8 (r4 < r3)
0008            
0053      // sho r0(value), r0(offset), 0xE(base) : set mem 0xE back to zero if branch not taken
000E
0000      // nop
0000      // nop
//=====================================================
// Test #8: BLT should take branch      => dmem[16] = 1
//=====================================================
0553      // sho r5(value), r0(offset), 0x10(base) : set mem 0x10 to one
0010
4333      // blt r3, r4, 8 (r3 < r4) 
0008            
0053      // sho r0(value), r0(offset), 0x10(base) : set mem 0x10 back to zero if branch not taken
0010
0000      // nop
0000      // nop

